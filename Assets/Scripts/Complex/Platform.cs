using System.Numerics;
using System;
using UnityEngine;
using System.Collections.Generic;

public class Platform : MonoBehaviour
{
    public float alpha;
    public float beta_real;
    public float beta_imag;
    Complex beta;
    public float gamma;

    public GameObject sphere;

    // To Do: make these hidden and generated by start method
    public GameObject planeCircle;
    public GameObject planeLine;
    GameObject sphereCircle;

    public GameObject tempp;
    public GameObject tempq;
    public GameObject tempc;
    public GameObject tempn;

    public Material lineMaterial;
    public int segments = 100;
    public int phiResolution = 100;
    public int thetaResolution = 100;
    public bool isBowl = true;

    private UnityEngine.Vector3 ParamOfSurface(double phi, double theta, double rs, UnityEngine.Vector3 cs)
    {
        return new UnityEngine.Vector3((float)(rs*Math.Sin(theta)*Math.Sin(phi)), (float)(rs*Math.Cos(theta)), (float)(rs*Math.Sin(theta)*Math.Cos(phi))) + cs;
    }

    private void RenderSpherePlatform(UnityEngine.Vector3 cs, UnityEngine.Vector3 n, double rs, UnityEngine.Vector3 c2, double r2)
    {
        // need to determine whether rendering cap or bowl
        double phiLower = 0;
        double phiUpper = 2 * Math.PI;
        double phiStep = (phiUpper - phiLower) / phiResolution;

        double thetaLower;
        double thetaUpper;
        if (isBowl)
        {
            thetaLower = Math.Atan2((c2 - cs).y, r2);
            thetaUpper = Math.PI;
        }
        else
        {
            thetaLower = 0;
            thetaUpper = Math.Atan2((c2 - cs).y, r2);
        }
        double thetaStep = (thetaUpper - thetaLower) / thetaResolution;

        List<UnityEngine.Vector3> vertices = new List<UnityEngine.Vector3>();

        for (double theta=thetaLower; theta<=thetaUpper; theta += thetaStep)
        {
            if (theta == 0 || theta == Math.PI)
            {
                vertices.Add(ParamOfSurface(0, theta, rs, cs));
            }
            else
            {
                for (double phi = phiLower; phi <= phiLower; phi += phiStep)
                {
                    vertices.Add(ParamOfSurface(phi, theta, rs, cs));
                }
            }
        }

        List<int> triangles = new List<int>();

        if (isBowl)
        {

        }
    }
    private void RenderCircleOutline(UnityEngine.Vector3 center, UnityEngine.Vector3 normal, double radius)
    {
        LineRenderer lineRenderer = sphereCircle.GetComponent<LineRenderer>();

        lineRenderer.material = lineMaterial;
        lineRenderer.widthMultiplier = 0.1f;
        lineRenderer.loop = true;
        lineRenderer.positionCount = segments + 1;

        // Generate circle points
        UnityEngine.Vector3[] circlePoints = new UnityEngine.Vector3[segments + 1];
        UnityEngine.Vector3 axis1, axis2;
        GetPerpendicularAxes(normal, out axis1, out axis2);

        for (int i = 0; i <= segments; i++)
        {
            float angle = (i * 2 * Mathf.PI) / segments;
            UnityEngine.Vector3 point = center + (float)radius * (Mathf.Cos(angle) * axis1 + Mathf.Sin(angle) * axis2);
            circlePoints[i] = point;
        }

        lineRenderer.SetPositions(circlePoints);
    }

    private void GetPerpendicularAxes(UnityEngine.Vector3 normal, out UnityEngine.Vector3 axis1, out UnityEngine.Vector3 axis2)
    {
        normal.Normalize();
        axis1 = UnityEngine.Vector3.Cross(normal, UnityEngine.Vector3.up);
        if (axis1.magnitude < 0.001f)
        {
            axis1 = UnityEngine.Vector3.Cross(normal, UnityEngine.Vector3.right);
        }
        axis1.Normalize();
        axis2 = UnityEngine.Vector3.Cross(normal, axis1).normalized;
    }
    private void SetSpherePlatform()
    {
        if (alpha != 0)
        {
            Complex centre = -beta / alpha;
            double r1 = Math.Sqrt(1 / alpha * (Math.Pow(beta.Magnitude, 2) - gamma));
            UnityEngine.Vector3 c1 = new UnityEngine.Vector3((float)centre.Real, 0, (float)centre.Imaginary);

            UnityEngine.Vector3 cs = sphere.transform.position;
            double rs = sphere.transform.localScale.x / 2;
            UnityEngine.Vector3 N = cs + new UnityEngine.Vector3(0, (float)rs, 0); // north pole

            UnityEngine.Vector3 p1 = c1 + new UnityEngine.Vector3((float)r1, 0, 0);
            UnityEngine.Vector3 q1 = c1 - new UnityEngine.Vector3((float)r1, 0, 0);

            double lambdap = -2 * rs * (p1.y - cs.y - rs) / (Math.Pow(p1.x - cs.x, 2) + Math.Pow(p1.y - cs.y - rs, 2) + Math.Pow(p1.z - cs.z, 2));
            double lambdaq = -2 * rs * (q1.y - cs.y - rs) / (Math.Pow(q1.x - cs.x, 2) + Math.Pow(q1.y - cs.y - rs, 2) + Math.Pow(q1.z - cs.z, 2));

            UnityEngine.Vector3 p2 = (p1 - N) * (float)lambdap + N;
            UnityEngine.Vector3 q2 = (q1 - N) * (float)lambdaq + N;

            UnityEngine.Vector3 c2 = (p2 - q2) * 0.5f + q2;
            double r2 = (0.5f * (p2 - q2)).magnitude;

            double i1 = c2.x - cs.x;
            double j1 = c2.y - cs.y;
            double k1 = c2.x - cs.x;

            double lambda = rs / Math.Sqrt(i1 * i1 + j1 * j1 + k1 * k1);

            UnityEngine.Vector3 r = (c2 - cs) * (float)lambda + cs;
            UnityEngine.Vector3 n = new UnityEngine.Vector3(r.x - cs.x, r.y - cs.y, r.z - cs.z).normalized; // normal to circle on sphere

            tempc.transform.position = c2;
            tempp.transform.position = p2;
            tempq.transform.position = q2;
            tempn.transform.position = c2 + n;

            RenderCircleOutline(c2, n, r2);
        }
    }
    private void SetPlanePlatform()
    {
        beta = new Complex(beta_real, beta_imag);

        if (alpha != 0) // platform is a circle
        {
            // for circle |z - c| = r
            double radius = Math.Sqrt(1 / alpha * (Math.Pow(beta.Magnitude, 2) - gamma));
            Complex centre = -beta / alpha;

            planeCircle.transform.position = new UnityEngine.Vector3((float)centre.Real, 0f, (float)centre.Imaginary);
            // default cylinder radius is 0.5 so for radius of x set scale to 2x
            planeCircle.transform.localScale = new UnityEngine.Vector3((float)(2 * radius), 0.1f, (float)(2 * radius));

            planeLine.SetActive(false);
            planeCircle.SetActive(true);
        }
        else // platform is a line
        {
            // for line ax + bz + c = 0
            double a = 2 * beta.Real;
            double b = 2 * beta.Imaginary;
            double c = gamma;

            double angle = Math.Atan2((float)b, (float)a) * Mathf.Rad2Deg;
            planeLine.transform.rotation = UnityEngine.Quaternion.Euler(0, (float)angle, 0);

            planeLine.SetActive(true);
            planeCircle.SetActive(false);
        }
    }
    void Start()
    {
        beta = new Complex(beta_real, beta_imag);
        sphereCircle = new GameObject("sphereCircle");
        sphereCircle.AddComponent<LineRenderer>();
    }

    void Update()
    {
        SetPlanePlatform();
        SetSpherePlatform();
    }
}
